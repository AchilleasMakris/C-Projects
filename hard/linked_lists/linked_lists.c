#include <stdio.h>
#include <stdlib.h>


struct Node {						// ορισμός του κόμβου μίας λίστας
    int data;						// ένας ακέραιος αριθμός
    struct Node* next;				// δείκτης στο επόμενο στοιχείο της λίστας
};


// υλοποίηση της swap
void swap(int *a, int *b) {
    // ...
    int tmp; /* Προσωρινή μεταβλητή για την αποθήκευση της τιμής του *a */
    tmp = *a; /* Αποθηκεύουμε την τιμή του *a στο tmp */
    *a = *b; /* Αντιγράφουμε την τιμή του *b στο *a */
    *b = tmp; /* Αντιγράφουμε την αποθηκευμένη τιμή (tmp) στο *b */
}

/* 1.Αν δεν βαλουμε & στο main call void(&a, &b) οι μεταβλητες θα αλλαξουν μονο τοπικα και οχι στην θεση μνημης που ειναι οι αρχικες μεταβλητες. */

/* Το α και το β θα αλλαξουν στην συναρτηση σαν β και α αλλα οχι στην main. */

/* υλοποίηση της find_min_max_array */
void find_min_max_array(int A[], int size, int *min, int *max) 
{
    /* Αρχικοποιούμε min και max με την πρώτη τιμή του πίνακα. */
    *max = A[0], *min = A[0];

    /* Διατρέχουμε όλα τα στοιχεία του πίνακα. */
    for(int i = 0; i < size; i++)
    {
        /* Αν το τρέχον στοιχείο είναι μεγαλύτερο από το αποθηκευμένο max, ενημερώνουμε το max. */
        if(A[i] > *max)
        {
            *max = A[i];   
        }
        /* Αν το τρέχον στοιχείο είναι μικρότερο από το αποθηκευμένο min, ενημερώνουμε το min. */
        if(A[i] < *min)
        {
            *min = A[i];
        }
    }  
}


// υλοποίηση της reverse_array 
void reverse_array(int A[], int size) 
{
    /* Διατρέχουμε τον μισό πίνακα (size / 2), γιατί κάθε swap αλλάζει δύο στοιχεία κάθε φορά. */
    for(int i = 0; i < size / 2; i++)
    {
        /* Ανταλλάσσουμε το στοιχείο στη θέση i με το συμμετρικό του από το τέλος. */
        swap(&A[i], &A[size - 1 - i]);
    }
}


// υλοποίηση της find_min_max_list
void find_min_max_list(struct Node* head, int *min, int *max) 
{
    /*  Αρχικοποιούμε το min και το max με την τιμή του πρώτου κόμβου. */
    *max = head->data;
    *min = head->data;

    /* Ορίζουμε έναν δείκτη για να διατρέξουμε τη λίστα, ξεκινώντας από τον δεύτερο κόμβο */
    struct Node* currentptr = head->next;
    /* Διατρέχουμε τη λίστα μέχρι να φτάσουμε στο τέλος (NULL). */
    while(currentptr != NULL)
    {
        /* Αν η τιμή του τρέχοντος κόμβου είναι μεγαλύτερη από το max, την ενημερώνουμε. */
        if(currentptr->data > *max)
        {
            *max = currentptr->data;
        }
        /* Αν η τιμή του τρέχοντος κόμβου είναι μικρότερη από το min, την ενημερώνουμε. */
        if(currentptr->data < *min)
        {
            *min = currentptr->data;
        }
        /* Προχωράμε στον επόμενο κόμβο. */
        currentptr = currentptr->next;
    }

}

// υλοποίηση της reverse_list
struct Node* reverse_list(struct Node* head) {
    struct Node* currentptr = head; /* Δείκτης στον τρέχον κόμβο, ξεκινά από την αρχή της λίστας */
    struct Node* prevptr = NULL; /* Δείκτης στον προηγούμενο κόμβο */
    struct Node* nextptr = NULL; /* Δείκτης στον επόμενο κόμβο, για να μην χαθεί η συνέχεια της λίστας */
    while(currentptr != NULL)
    {
        nextptr = currentptr -> next; /* Αποθηκεύουμε τον επόμενο κόμβο για να μη χαθεί η συνέχεια της λίστας */
        currentptr->next = prevptr; /* Αντιστροφή της κατεύθυνσης: ο τρέχων κόμβος δείχνει στον προηγούμενο */
        prevptr = currentptr; /* Ο προηγούμενος κόμβος γίνεται ο τρέχων */
        currentptr = nextptr; /* Μετακινούμε τον currentptr στον επόμενο κόμβο*/
    }
    return prevptr; /* Ο prevptr είναι πλέον η νέα κεφαλή της λίστας */
}


int main() {
    int A[7];					// πίνακας ακεραίων 7 θέσεων, για δοκιμή των συναρτήσεων
    int size;					// το μέγεθος του πίνακα 
	int i;						// βοηθητική μεταβλητή για την υλοποίηση βρόχων
    int min, max;				// μεταβλητές που θα χρησιμοποιηθούν για αποτελέσματα 
    							// που θα επιστραφούν ως μικρότερες και μεγαλύτερες
    							// τιμές από τις συναρτήσεις
    struct Node* head;			// δείκτης στην αρχή της λίστας
    struct Node* temp;			// βοηθητικός δείκτης σε λίστα
    struct Node* new_node;		// δείκτης που θα χρησιμοποιηθεί για τη δημιουργία νέου κόμβου
    
    // system("chcp 1253>nul");	// για να έχουμε ελληνικά στα windows

    // αρχικοποίηση του πίνακα για τη δοκιμή
	A[0] = 4;				
    A[1] = 5;
    A[2] = 8;
    A[3] = 2;
    A[4] = 9;
    A[5] = 8;
    A[6] = 1;
    size = 7;

	// εμφάνιση του πίνακα στην οθόνη
    printf("Αρχικός Πίνακας: ");	
    for (i = 0; i < size; i++) {	// ένα ένα τα στοιχεία διαπερνούνται
        printf("%d ", A[i]);	 	// και τυπώνονται στην οθόνη
    }
    printf("\n");
	
	// κλήση και εμφάνιση αποτελεσμάτων της find_min_max_array
    find_min_max_array(A, size, &min, &max); 
    printf("Min στον πίνακα: %d, Max στον πίνακα: %d\n", min, max);

	// κλήση και εμφάνιση αποτελεσμάτων της reverse_array
    reverse_array(A, size);
    printf("Πίνακας μετά την αντιστροφή: ");
    for (i = 0; i < size; i++) {  	// ένα ένα τα στοιχεία διαπερνούνται
        printf("%d ", A[i]);		// και τυπώνονται στην οθόνη
    }
    printf("\n");

	// δημιουργία λίστας για δοκιμή
    head = NULL;	// πρώτο στοιχείο
    temp = NULL;	// βοηθητικός δείκτης στο τελευταίο στοιχείο
    for (i = 0; i < size; i++) {
    	// οι ακέραιοι από τον πίνακα εισάγονται στη λίστα
        new_node = (struct Node*)malloc(sizeof(struct Node));  // νεός κόμβος
        new_node->data = A[i];		// με το στοιχείο από τον πίνακα
        new_node->next = NULL;		// το οποίο θα είναι αυτή τη στιγμή τελευταίο
        if (head == NULL) {			// αν είναι το πρώτο στοιχείο της λίστας
            head = new_node;		// τοποθετούμε εκεί τον δείκτη
        } else {					// αλλιώς 
            temp->next = new_node;	// το τοποθετούμε στο τέλος
        }
        temp = new_node;			// και κάνουμε αυτό τελευταίο
    }

	// εμφάνιση της λίστας στην οθόνη
    printf("Αρχική λίστα: ");  
    struct Node* current = head;	// ξεκινούμε από το πρώτο στοιχείο
    while (current != NULL) {		// επισκεπτόμαστε κάθε στοιχείο μέχρι το τελευταίο
        printf("%d -> ", current->data);  // τυπώνουμε το πεδίο data
        current = current->next;	// μεταβαίνουμε στο επόμενο στοιχείο
        							// για να συνεχιστεί ο βρόχος
    }
    printf("NULL\n");

	// κλήση και εμφάνιση αποτελεσμάτων της find_min_max_list
    find_min_max_list(head, &min, &max);
    printf("Min στη λίστα: %d, Max στη λίστα: %d\n", min, max);

	// κλήση και εμφάνιση αποτελεσμάτων της reverse_list
    head = reverse_list(head);
    printf("Λίστα μετά την αντιστροφή: ");
    current = head;				// ξεκινούμε από το πρώτο στοιχείο
    while (current != NULL) {	// επισκεπτόμαστε κάθε στοιχείο μέχρι το τελευταίο
        printf("%d -> ", current->data); // τυπώνουμε το πεδίο data
        current = current->next;	// μεταβαίνουμε στο επόμενο στοιχείο
        							// για να συνεχιστεί ο βρόχος
    }
    printf("NULL\n");

	// ολοκλήρωση εκτέλεσης
    return 0;
}